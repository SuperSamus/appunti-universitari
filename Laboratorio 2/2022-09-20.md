# C

## Funzioni

- **Astrazione**: implementano una certa funzionalità per essere riutilizzata.
- Il passaggio viene sempre fatto per *valore* (copia)
- Per cambiare il valore degli argomenti si usano i [puntatori](#puntatori)
- [Si può avere un numero di argomenti variabile](#parametri-riga-di-comando)

## Sintassi

- **Dichiarazione**
    - Se manca: **linker error**
    - Spesso si fa in file separati, gli **header** (`.h`)
- **Deifnizione**
    - Se manca: **compiler error**

## I/O

- Libreria standard: `stdio`
    - `printf()`: scrive su `stdout`
        - Può contenenere sengaposti `%...` per includere valori di variabili
    - `scanf()`: legge da `stdin`
        - Prende anche degli indirizzi (`&`) delle variabili dove salvare i valori letti
        - Restituisce il numero di argomenti per cui l'input è valido
        - `*` gli fa ignorare la parte invalida dell'input
        - Si possono usare espressioni regolari

### Segnaposti (dopo `%`)

- Interi decimali: `d`, `u` (unsigned)
    - Si può anteporre `l` (long) o `h` (short)
- Double floating point `f`
- Carattere `c`
- Stringa `s`

## Scoping

- I nomi sono utilizzabili fino al blocco in cui sono dichiarati
- Le funzioni sono sempre globali nel file
- Dichiarazioni `extern`: visibili automaticamente anche in altri file
- Variabili `static` locali: persistenti tra una chiamata della funzione a l'altra
- Dichiarazioni `static` globali: visibili solo nel file in cui sono dichiarate, non si possono importare
- **Shadowing**: dichiarare una variabile con lo stesso nome in un sottoblocco

## Gestione memoria

- Programma e dati - memoria
- Zona dati
    - Dati statici
        - Variabili globali
        - Variabili statiche
    - **Stack**: record di attivazione
        - 1 per ogni blocco di codice (incluso chiamate funzioni)
        - Spazio per variabili locali
    - **Heap**: dati dinamici (*runtime*), frammentati
        - Memoria allocata dinamicamente, accessa coi *puntatori*

## Puntatori

- Qualsiasi dato/istruzione che sta in memoria ha un *valore* e un *indirizzo di memoria*
- Un puntatore è una *variabile* che contiene un indirizzo di memoria
    - Ha a sua volta un indirizzo di memoria
    - Il tipo indica il dato che si aspetta di vedere nell'indirizzo a cui punta
- Dereferenziare un puntatore: `*`
- Ottenere l'indirizzo di una variabile: `&`

## Array

- `int a[10];`
    - Alloca sullo stack 10 indirizzi continui
    - Memorizza in `a` l'indirizzo della prima cella
        - `a` è un puntatore
    - Array multidimensionali: negli argomenti delle funzioni, serve specificare la dimensione di tutte le "dimensioni" (eccetto la prima)

## Parametri riga di comando

```c
int main(int argc, char* argv[])
```

- `argv[0]` nome del programma
- Numero parametri variabile con **ellipsis** (`...`): `void f(char x, ...)`
    - È necessario almeno un parametro "normale"
    - Per accedere ai parametri si usano macro definiti in `stdarg.h`
        - `va_list` (tipo)
        - `va_start` (funzione)
        - `va_arg` (funzione)
        - `va end` (funzione)

```c
#include <stdarg.h>
#include <stdio.h>

double sum(int n, ...) {
  double sum = 0;
  va_list args;
  va_start(args, n);

  for (int i = 0; i < n; ++i) {
    sum += va_arg(args, double);
  }

  va_end(args);
  return sum;
}

int main() {
  printf("%f %f %f", sum(2, 7., 3.), sum(7, 1., 2., 3., 4., 5., 6., 7.), sum(0));
}
```