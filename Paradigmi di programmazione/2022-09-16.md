# Informatica

Nata ad inizio 1900, riposta alla **crisi dei fondamenti**.

- Inizio 1600: sviluppo calcolo
    - Paradosso infinito
        - $\mathbb{N}=\mathbb{Z} (\equiv \mathbb{N}*\mathbb{N})$
    - Infinitesimi
        - $dx, dy \neq 0$
        - Chain rule: $\frac{dx}{dy}=\frac{dx}{dz}\frac{dz}{dy}$
    - Definizione limiti
    - ...
- 1800 geometrie non-euclidee

La matematica sta perdendo il suo criterio di certezza.

## Crisi dei fondamenti

### Cantor, Dedekind

- Consistenza delle analisi <- Geometria
    - Teoria dei sistemi numerici
        - **Aritmetica** ($\mathbb{N},+,...$)

### Frege

- **Logismo**: fondare la matematica sulla logica (invece che il contrario)
- *Ideografia*
    - Libro che introduce tra le varie cose la **logica del primo ordine** (#FOL)
    - Modus ponens: $A \rightarrow B, A \vdash B$

Mancava solo di costruire l'aritmetica su questo linguaggio. Ma la teoria che creò è risultata inconsistente.

### Hilbert

Uno dei matematici più famosi del 1900, conosciuto per i lavori di logica e per i 23 problemi di Hilbert.

- La matematica si basava sul **metodo assiomatico**
    - Dagli assiomi si ottengono nuove formule, che diventano **teoremi**
    - #FOL (first-order logic) + Assiomi
        - Peano Arithmetic (PA)
            - $\forall{x} \quad \neg (0=Successor(x))$
            - $\forall x,y \quad x+y=y+x$
            - ...
- Cosa deve avere una teoria T:
    - Consistenza
        - La teoria non contraddice se stessa $\neg(T \land \neg T)$
    - Completezza
        - La teoria dimostra tutto il dimostrabile $T \vdash A \lor T \vdash \neg A$)
    - Decidibilità
        - Data una formula nella FOL, esiste una procedura meccanica che determina se la formula è dimostrabile.

Il lavoro di un matematico è dimostrare i teoremi, quindi una procedura che consente ciò li toglierebbe il lavoro.

Gödel dimostra che la FOL è completa. Anche l'aritmetica di Peano lo è? Gödel dimostra il **teorema di incompletezza**: la logica dell'aritmetica di Peano (e qualsiasi sistema logico che codifica l'aritmetica) non è completa, o se è completa è inconsistente.

Resta però la decidibilità.

FOL: $FOL \vdash A$

## Procedura di calcolo

Dati in input -> Dati in output

- $f: \mathbb{N} \rightarrow \mathbb{N}$ **NO**
    - Procedure troppo restrittive, non possono non ritornare niente.
- $f: \mathbb{N} \rightharpoonup \mathbb{N}$
    - Funzione parziale

Ma tutte le funzioni parziali sono calcolabili? Ce ne sono troppe... Alcune funzioni sono calcolabili:

1.  Funzioni elementari (come $Successore$)
2.  $f,g \; \text{calcolabili} \Rightarrow g \circ f \; \text{calcolabili}$
3.  Funzioni ricorsive (che comprendono tra l'altro 1. e 2.)

Per loro: $[\mathbb{N} \rightharpoonup \mathbb{N}] \supseteq Ricorsive$

Questo è un approccio. Approcci sono:

1.  Funzioni ricorsive
2.  Church ($\lambda$-calcolo)
3.  Turing
    - Algoritmo = Regola che una persona può seguire in modo meccanico e preciso

### Turing

**Macchina di Turing**: quintupla $<Q,a,b,x,S>$
\* Stato
\* Simbolo
\* Scrivo b
\* Sposto il nastro: sinistra/destra/fermo
\* Arriva allo stato S.

$f: \mathbb{N} \rightharpoonup \mathbb{N} \; \text{calcolabile} \Leftrightarrow \exists M. \forall n \in \mathbb{N} \quad M(n) \downarrow \land M(n) = m \Leftrightarrow f(n) \downarrow \land f(n)=m$

Una funzione f è calcolabile se e solo se esiste una macchina di Turing in grado di implementare in tempo finito ($\downarrow$).

Problema: nell'insieme delle funzioni parziali esistono funzioni non calcolabili, **halting problem**.

Immagino una funzione che prende una macchina di Turing e restituisce un numero: si può fare, tutti gli elementi della quintupla sono finiti. (E si può fare anche l'inverso)

Halting problem: questo problema è indecidibile.

$$
f(n) =
  \begin{cases}
    M_n(n) \downarrow \\
    \uparrow
  \end{cases}

$$

#### Ogni macchina ha un programma

Esiste una macchina di Turing $M$ universale $U$.

$U(n,m) \rightarrow M_n(m)$

* * *

- Macchina (hardware)
- Istruzione (programma)
- Input/dati

Dati $\equiv$ Programma

##### Macchina programmabile

- Interprete
- Programma memorizzato

C'è anche bisogno di:

- Memoria (dati programmi)
- CPU
- Istruzioni

Questo è l'approccio dell'**analisi imperativa**.

### Church (1930)

Funzioni ricorsive $\equiv$ $\lambda$-calcolo $\equiv$ Macchina di Turing

Vecchia definizione funzione: $\{(x,y)|f(x)=y\}$

Church: definizione di funzione come regola. #astrazione

#### Tesi di Church-Turing

> Se un problema è umanamente calcolabile, allora esisterà una macchina di Turing in grado di risolverlo (cioè di calcolarlo)